#!/usr/bin/env python3

import argparse
from datetime import datetime, UTC
import os
import logging
import random
import shutil
import subprocess
import sys
import string
import tempfile
from typing import Callable

try:
    import argcomplete
    has_argcomplete = True
except ImportError:
    has_argcomplete = False

whoami = "tests"
def env(var, default=None):
    return os.environ.get("DOT_NVIM_TESTS_" + var, default)
logger = logging.getLogger(whoami)

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))

def temporary_directory(what=None):
    return tempfile.TemporaryDirectory(prefix=f"{whoami}-{what + '-' if what else ''}")

def fresh_salt(n=5):
    alphabeth = string.ascii_letters + string.digits
    return ''.join(random.choices(alphabeth, k=n))

def setup_logger(level):
    logger.setLevel(level.upper())

    ch = logging.StreamHandler()
    ch.setLevel(level.upper())

    f = logging.Formatter(fmt="%(asctime)s:%(name)s:%(levelname)s %(message)s", datefmt="%Y-%m-%dT%H:%M:%S%z")
    ch.setFormatter(f)

    logger.addHandler(ch)

def parse_args(build: Callable[[], argparse.ArgumentParser]) -> argparse.Namespace:
    early = argparse.ArgumentParser(add_help=False)
    main_parser = build()

    for p in [ early, main_parser ]:
        p.add_argument("--log", default=env("LOG_LEVEL", "INFO"), help="set log level")

    if has_argcomplete:
        for p in [ early, main_parser ]:
            p.add_argument("--completion-script", action="store_true", help="print script that when sourced configures shell completion, then exit")

    args, _ = early.parse_known_args()

    setup_logger(args.log)
    logger.debug("early args: %s", args)

    if has_argcomplete and args.completion_script:
        prog = os.path.basename(sys.argv[0])
        sys.stdout.write(argcomplete.shellcode([ prog ]))
        sys.exit(0)

    if has_argcomplete:
        argcomplete.autocomplete(main_parser)

    return main_parser.parse_args()

def main_parser() -> argparse.ArgumentParser:
    description = "dot-nvim tests"
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument("-w", "--workdir", default=env("WORKDIR"), help="workdir")
    parser.add_argument("-q", "--quiet", action="store_true")
    parser.add_argument("--timeout", type=float, default=2.0)

    default_target = os.path.realpath(os.path.join(SCRIPT_DIR, "..", "nvim"))
    parser.add_argument("-t", "--target", default=env("TARGET", default_target), help="neovim target")

    tests = parser.add_mutually_exclusive_group(required=True)
    tests.add_argument("-S", "--sanity-check", action="store_true")
    tests.add_argument("-M", "--main", action="store_true")
    tests.add_argument("-T", "--filetype")

    return parser

def main(args, workdir):
    if args.main:
        test_case = "main"
    elif args.sanity_check:
        test_case = "sanity-check"
    elif args.filetype:
        test_case = "ft:" + args.filetype
    else:
        raise NotImplementedError()
    logger.info("test-case: %s", test_case)

    logger.debug("workdir: %s", workdir)
    ts = datetime.now(UTC).strftime("%y%m%dT%H%M%SZ")
    salt = fresh_salt()
    testdir = os.path.join(workdir, f"{ts}-{test_case}-{salt}")
    logger.info("testdir: %s", testdir)
    os.makedirs(testdir)

    result_path = os.path.join(testdir, "result")
    env = {
        "DOT_NVIM_TESTS": test_case,
        "DOT_NVIM_TESTS_RESULT_PATH": result_path,
        **os.environ
    }

    if args.sanity_check:
        env["DOT_NVIM_TESTS_SANITY_CHECK"] = "1"

    unbuffer = shutil.which("unbuffer")
    assert unbuffer is not None

    tty = os.path.join(testdir, "tty")

    cmdline = [ unbuffer ]
    cmdline += [ args.target ]
    with open(tty, "wb") as f:
        p = subprocess.run(cmdline, cwd=testdir, env=env, timeout=args.timeout, stdout=f, check=False)

    with open(result_path) as f:
        ls = f.readlines()
    ls = [ l.rstrip() for l in ls ]
    result = bool(int(ls[2]))
    logger.info("result: %s", result)
    main_time = (float(ls[1]) - float(ls[0]))*1e3
    logger.info("main.lua duration: %fms", main_time)
    msg = ls[3:]
    logger.debug("message: %s", msg)

    if not args.quiet:
        for l in msg:
            print(l)

    if not args.sanity_check:
        return p.returncode == 0
    else:
        return p.returncode == 1

if __name__ == "__main__":
    args = parse_args(main_parser)
    logger.debug("args: %s", args)

    if args.workdir is not None:
        res = main(args=args, workdir=args.workdir)
    else:
        with temporary_directory() as tmp:
            res = main(args=args, workdir=tmp)

    sys.exit(0 if res else 1)
