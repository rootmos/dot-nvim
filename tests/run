#!/usr/bin/env python3

import argparse
from datetime import datetime, UTC
import os
import logging
import random
import shutil
import subprocess
import sys
import string
import tempfile
from typing import Callable

try:
    import argcomplete
    has_argcomplete = True
except ImportError:
    has_argcomplete = False

whoami = "tests"
def env(var, default=None):
    return os.environ.get("DOT_NVIM_TESTS_" + var, default)
logger = logging.getLogger(whoami)

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))

def temporary_directory(what=None):
    return tempfile.TemporaryDirectory(prefix=f"{whoami}-{what + '-' if what else ''}")

def fresh_salt(n=5):
    alphabeth = string.ascii_letters + string.digits
    return ''.join(random.choices(alphabeth, k=n))

def setup_logger(level):
    logger.setLevel(level.upper())

    ch = logging.StreamHandler()
    ch.setLevel(level.upper())

    f = logging.Formatter(fmt="%(asctime)s:%(name)s:%(levelname)s %(message)s", datefmt="%Y-%m-%dT%H:%M:%S%z")
    ch.setFormatter(f)

    logger.addHandler(ch)

def parse_args(build: Callable[[], argparse.ArgumentParser]) -> argparse.Namespace:
    early = argparse.ArgumentParser(add_help=False)
    main_parser = build()

    for p in [ early, main_parser ]:
        p.add_argument("--log", default=env("LOG_LEVEL", "INFO"), help="set log level")

    if has_argcomplete:
        for p in [ early, main_parser ]:
            p.add_argument("--completion-script", action="store_true", help="print script that when sourced configures shell completion, then exit")

    args, _ = early.parse_known_args()

    setup_logger(args.log)
    logger.debug("early args: %s", args)

    if has_argcomplete and args.completion_script:
        prog = os.path.basename(sys.argv[0])
        sys.stdout.write(argcomplete.shellcode([ prog ]))
        sys.exit(0)

    if has_argcomplete:
        argcomplete.autocomplete(main_parser)

    return main_parser.parse_args()

def main_parser() -> argparse.ArgumentParser:
    description = "dot-nvim tests"
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument("-w", "--workdir", default=env("WORKDIR"), help="workdir")
    parser.add_argument("-q", "--quiet", action="store_true")

    parser.add_argument("--timeout", type=float, default=2.0)
    parser.add_argument("-I", "--interactive", action="store_true")

    default_target = os.path.realpath(os.path.join(SCRIPT_DIR, "..", "nvim"))
    parser.add_argument("-t", "--target", default=env("TARGET", default_target), help="neovim target")

    tests = parser.add_mutually_exclusive_group(required=True)
    tests.add_argument("-S", "--sanity-check", action="store_true")
    tests.add_argument("-M", "--main", action="store_true")
    tests.add_argument("-T", "--filetype")

    return parser

def main(args, workdir):
    if args.main:
        test_case = "main"
    elif args.sanity_check:
        test_case = "sanity-check"
    elif args.filetype:
        test_case = "ft:" + args.filetype
    else:
        raise NotImplementedError()
    logger.info("test-case: %s", test_case)

    logger.debug("workdir: %s", workdir)
    ts = datetime.now(UTC).strftime("%y%m%dT%H%M%SZ")
    salt = fresh_salt()
    testdir = os.path.join(workdir, f"{ts}-{test_case}-{salt}")
    logger.info("testdir: %s", testdir)
    os.makedirs(testdir)

    result_path = os.path.join(testdir, "result")
    messages_path = os.path.join(testdir, "messages")
    env = {
        "DOT_NVIM_TESTS": test_case,
        "DOT_NVIM_TESTS_RESULT_PATH": result_path,
        "DOT_NVIM_TESTS_MESSAGES_PATH": messages_path,
        "DOT_NVIM_ME": "",
        **os.environ
    }

    if args.sanity_check:
        env["DOT_NVIM_TESTS_SANITY_CHECK"] = "1"

    cmdline = []
    kwargs = {
        "cwd": testdir,
        "env": env,
        "check": False,
    }

    if not args.interactive:
        unbuffer = shutil.which("unbuffer")
        assert unbuffer is not None
        cmdline += [ unbuffer ]

        kwargs["stdin"] = subprocess.DEVNULL
        tty = os.path.join(testdir, "tty")
        kwargs["stdout"] = open(tty, "wb")

        kwargs["timeout"] = args.timeout

    cmdline += [ args.target ]
    p = subprocess.run(cmdline, **kwargs)

    with open(result_path) as f:
        ls = [ l.rstrip() for l in f.readlines() ]
    result = bool(int(ls[2]))
    logger.info("result: %s", result)
    main_time = (float(ls[1]) - float(ls[0]))*1e3
    logger.info("main.lua duration: %fms", main_time)

    error = ls[3:]
    logger.debug("pcall(main) error: %s", error)
    if error:
        if not args.quiet:
            for l in error:
                print(l)

    with open(messages_path) as f:
        messages = [ l.rstrip() for l in f.readlines() ]
    logger.debug("messages: %s", messages)
    if not args.quiet:
        for l in messages:
            print(l)

    good = []
    bad = []

    expected_returncode = 0 if not args.sanity_check else 1
    if p.returncode == expected_returncode:
        good.append(f"correct exit status: {p.returncode} == {expected_returncode}")
    else:
        bad.append(f"unexpected exit status: {p.returncode} != {expected_returncode}")

    if len(messages) == 0:
        good.append(f"no messages")
    else:
        bad.append(f"too noisy")

    if not args.sanity_check:
        if result:
            good.append(f"main.lua returned")
        else:
            bad.append(f"main.lua errored")

        if len(error) == 0:
            good.append(f"main.lua didn't raise any errors")
        else:
            bad.append(f"main.lua raised error")
    else:
        if not result:
            good.append(f"main.lua errored as expected")
        else:
            bad.append(f"main.lua returned unexpectedly")

        if len(error) == 1 and error[0].endswith("make sure errors are caught"):
            good.append(f"main.lua raised the expected error")
        else:
            bad.append(f"main.lua did not raise the expected error: {error}")

    if not bad:
        logger.info("OK:")
        verdict = True
        report = logging.INFO
    else:
        logger.error("FAIL:")
        verdict = False
        report = logging.ERROR

    for c in good:
        logger.log(report, "  +" + c)
    for c in bad:
        logger.log(report, "  -" + c)

    return verdict

if __name__ == "__main__":
    args = parse_args(main_parser)
    logger.debug("args: %s", args)

    if args.workdir is not None:
        res = main(args=args, workdir=args.workdir)
    else:
        with temporary_directory() as tmp:
            res = main(args=args, workdir=tmp)

    sys.exit(0 if res else 1)
