#!/usr/bin/env python3
# 2026-01-15T06:15:10+01:00 SHA-256:e760362a7ea2e4f89f658c5f7d109289cd928040638f286ea1a47841aa7f0407

import argparse
import contextlib
import datetime
import hashlib
import json
import os
import stat
import sys
import urllib.request

import logging
logger = logging.getLogger(__name__)

whoami = "fetch"
env_prefix = f"{whoami.upper()}_"

def env(var, default=None):
    return os.environ.get(env_prefix + var, default)

def chmod_plus_x(path):
    umask = os.umask(0)
    os.umask(umask)
    os.chmod(path, os.stat(path).st_mode | ((stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH) & ~umask))

def figure_out_version():
    with open(__file__, "rb") as this:
        ls = this.readlines()
        shebang = ls[0]
        assert shebang.startswith(b"#!")

        h = hashlib.sha256()
        for l in ls[1:]:
            h.update(l)
        return h.hexdigest()

def parse_args():
    parser = argparse.ArgumentParser(
            description = "One script to fetch them all and in git bind them",
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument("-v", "--version", action="version", version=figure_out_version())

    parser.add_argument("--log", default=env("LOG_LEVEL", "WARN"), help="set log level")

    default_root = env("ROOT", ".")
    default_manifest_filename = env("MANIFEST_FILENAME", f".{whoami}.json")
    parser.add_argument("--root", metavar="ROOT", default=default_root, help="act relative the directory ROOT")
    parser.add_argument("--manifest-filename", metavar="FILENAME", default=default_manifest_filename, help="load manifest from FILENAME (relative to the ROOT)")
    parser.add_argument("--manifest", metavar="PATH", default=env("MANIFEST"), help="load manifest from PATH")

    subparsers = parser.add_subparsers(dest="cmd")

    add_cmd = subparsers.add_parser("add")
    add_cmd.add_argument("--sha256", metavar="SHA256")
    add_cmd.add_argument("url", metavar="URL")
    add_cmd.add_argument("target", metavar="TARGET")

    download_cmd = subparsers.add_parser("download")
    download_cmd.add_argument("target", metavar="TARGET", nargs="*")

    steal_this_script_cmd = subparsers.add_parser("steal-this-script")
    steal_this_script_cmd.add_argument("output", metavar="OUTPUT", nargs="?")

    return parser.parse_args()

def setup_logger(level):
    l = logging.getLogger("fetch")
    l.setLevel(level)

    ch = logging.StreamHandler()
    ch.setLevel(level)

    f = logging.Formatter(fmt="%(asctime)s:%(name)s:%(levelname)s %(message)s", datefmt="%Y-%m-%dT%H:%M:%S%z")
    ch.setFormatter(f)

    l.addHandler(ch)

    return l

def download(url, target=None):
    m = hashlib.sha256()
    if target is None:
        logger.info("fetching: %s", url)
    else:
        logger.info("fetching: %s -> %s", url, target.name)

    hdr = {
        "User-Agent": env("USER_AGENT", whoami),
    }
    req = urllib.request.Request(url, headers=hdr)
    with urllib.request.urlopen(req) as f:
        while True:
            bs = f.read(4096)
            if len(bs) == 0:
                break
            logger.debug("fetching; %s: %s bytes", url, len(bs))
            m.update(bs)
            if target:
                target.write(bs)
    sha256 = m.hexdigest()
    logger.info("fetched; %s: SHA256 %s", url, sha256)
    return sha256

def sha256_file(path):
    with open(path, "rb") as f:
        m = hashlib.sha256()
        while True:
            bs = f.read(4096)
            if len(bs) == 0:
                break
            m.update(bs)
        return m.hexdigest()

class Manifest:
    def __init__(self, path):
        self.path = path

        self._items = {}
        if os.path.exists(self.path):
            logger.debug("loading manifest: %s", self.path)
            with open(self.path, "r", encoding="UTF-8") as f:
                for i in map(Item.from_dict, json.load(f)):
                    self._items[i.target] = i
        else:
            logger.debug("empty manifest intended for: %s", self.path)

    def __contains__(self, item):
        if isinstance(item, Item):
            item = item.target
        return item in self._items

    def __getitem__(self, item):
        if isinstance(item, Item):
            item = item.target
        return self._items[item]

    def items(self):
        yield from self._items.values()

    def add(self, item):
        if item.target in self._items:
            raise NotImplementedError()
        self._items[item.target] = item

    def to_dict(self):
        items = sorted(self._items.values(), key=lambda i: i.target)
        items = map(lambda i: i.to_dict(), items)
        return list(items)

    def save(self):
        logger.debug("saving manifest: %s", self.path)
        with open(self.path, "w", encoding="UTF-8") as f:
            json.dump(self.to_dict(), f, sort_keys=True, indent=4)

class Item:
    def __init__(self, url, target, sha256=None, timestamp=None):
        self.url = url
        self.target = target
        self.sha256 = sha256
        self.timestamp = timestamp
        self.local = None

    def path(self, root=None):
        return os.path.join(root or os.getcwd(), self.target)

    def exists(self, root=None):
        return os.path.exists(self.path(root))

    def download(self, root=None):
        path = self.path(root)
        self.timestamp = datetime.datetime.now().astimezone()
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.local = path
        try:
            with open(path, "xb") as f:
                sha256 = download(self.url, f)
        except FileExistsError as exc:
            sha256 = sha256_file(path)
            if self.sha256 is not None:
                if self.sha256 != sha256:
                    raise RuntimeError("checksum failed", path, self.url, sha256, self.sha256) from exc
            else:
                raise
        if self.sha256 is not None:
            if self.sha256 != sha256:
                raise RuntimeError("checksum failed", self.url, sha256, self.sha256)
        self.sha256 = sha256
        return self

    def verify(self, root=None, url=None, sha256=None):
        if url is not None and self.url != url:
            raise RuntimeError("url doesn't match manifest", url, self.url)

        if sha256 is not None and self.sha256 != sha256:
            raise RuntimeError("sha256 doesn't match manifest", sha256, self.sha256)

        path = self.path(root)
        logger.debug("verifying: %s", path)
        h = sha256_file(path)
        if self.sha256 != h:
            raise RuntimeError("target checksum failed", path, h, self.sha256)
        self.local = path
        return self

    def to_dict(self):
        d = {
            "target": self.target,
            "url": self.url,
            "sha256": self.sha256,
            "timestamp": self.timestamp.isoformat(timespec="seconds"),
        }

        return d

    @staticmethod
    def from_dict(d):
        return Item(
            target = d["target"],
            url = d["url"],
            sha256 = d["sha256"],
            timestamp = datetime.datetime.fromisoformat(d["timestamp"]),
        )

def resolve_root_and_manifest(args):
    root = args.root
    if root == ".":
        root = os.getcwd()
    logger.debug("root: %s", root)

    manifest_path = args.manifest
    if args.manifest is None:
        manifest_path = os.path.join(root, args.manifest_filename)

    manifest = Manifest(manifest_path)
    return root, manifest

def do_add(args):
    root, manifest = resolve_root_and_manifest(args)

    target = os.path.relpath(os.path.join(root, args.target), start=root)
    if target in manifest:
        item = manifest[target]
        if not item.exists(root=root):
            item = item.download(root=root)
        item = item.verify(url=args.url, sha256=args.sha256, root=root)
    else:
        item = Item(url=args.url, sha256=args.sha256, target=target).download(root=root)
        manifest.add(item)

    assert item.local is not None
    print(os.path.relpath(item.local, start=root))

    manifest.save()

def do_download(args):
    root, manifest = resolve_root_and_manifest(args)

    items = set()
    if vars(args).get("target"):
        for i in manifest.items():
            if i.target in args.target:
                items.add(i)
    else:
        items = manifest.items()

    for i in items:
        if i.exists(root=root):
            i.verify(root=root)
        else:
            i.download(root=root)
        print(os.path.relpath(i.local, start=root))

def do_steal_this_script(args):
    if args.output is None:
        dst = contextlib.nullcontext(sys.stdout.buffer)
    else:
        dst = open(args.output, "wb")

    with open(__file__, "rb") as src, dst as dst:
        ls = src.readlines()
        shebang = ls[0]
        assert shebang.startswith(b"#!")
        dst.write(shebang)

        h = hashlib.sha256()
        for l in ls[1:]:
            h.update(l)
        sha256 = h.hexdigest()

        now = datetime.datetime.now().astimezone().isoformat(timespec="seconds")
        dst.write(f"# {now} SHA-256:{sha256}\n".encode("UTF-8"))

        for l in ls[1:]:
            dst.write(l)

    if args.output is not None:
        chmod_plus_x(args.output)

def main():
    args = parse_args()
    logger = setup_logger(args.log.upper())
    logger.debug("args: %s", args)

    if args.cmd == "add":
        do_add(args)
    elif args.cmd is None or args.cmd == "download":
        do_download(args)
    elif args.cmd == "steal-this-script":
        do_steal_this_script(args)
    else:
        raise RuntimeError(f"unexpected command: {args.cmd}")

if __name__ == "__main__":
    main()
